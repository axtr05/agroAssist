{"ast":null,"code":"export const sendMsgToAI = async (msg, onChunkCallback) => {\n  const API_KEY = process.env.REACT_APP_GEMINI_KEY;\n\n  // 1. --- CHANGED ENDPOINT ---\n  // We now use \"streamGenerateContent\" and add \"alt=sse\"\n  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${API_KEY}`;\n  const instructedMsg = `\n  You are \"AgroAssist,\" an expert agricultural assistant for farmers.\n  Your job is to answer questions related to agriculture ONLY.\n\n  --- YOUR PRIMARY RULE ---\n  1. Read the user's question.\n  2. Decide if it is related to agriculture (farming, crops, soil, fertilizer, weather for farming, farm pests, market prices for crops, etc.).\n  3. IF THE QUESTION IS NOT about agriculture (e.g., politics, sports, history, who you are), you MUST ignore all other rules and respond ONLY with this exact sentence: \"I am only programmed to answer queries regarding agriculture and that only alone.\"\n\n  --- IF THE QUESTION IS ABOUT AGRICULTURE, FOLLOW THESE RULES ---\n  1. **LANGUAGE RULE: You MUST respond in the exact same language as the User's question.** (e.g., If the user asks in Hindi, you must answer in Hindi).\n  2. Give the most important, actionable answer in the very first sentence.\n  3. Format your entire response using Markdown. Use paragraphs for explanations and bullet points for lists.\n  4. Use simple, easy-to-understand language. Do NOT use scientific jargon.\n  5. If the user's question can be answered in a short paragraph, do so (2-3 sentences max).\n  6. If the user's question asks for a list of items (like fertilizers or steps), you MUST use a simple Markdown bulleted list (\\`* item\\`).\n  7. Ensure proper line breaks and spacing for readability.\n\n  User's question: ${msg}\n  `;\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      contents: [{\n        role: \"user\",\n        parts: [{\n          text: instructedMsg.trim()\n        }]\n      }]\n    })\n  };\n  try {\n    // 2. --- START STREAMING FETCH ---\n    const response = await fetch(API_URL, requestOptions);\n    if (!response.ok) {\n      var _errorData$error;\n      // Handle HTTP errors\n      const errorData = await response.json();\n      console.error(\"Gemini API Error Response:\", errorData);\n      throw new Error(`API request failed with status ${response.status}: ${(errorData === null || errorData === void 0 ? void 0 : (_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || 'Unknown error'}`);\n    }\n\n    // 3. --- READ THE STREAM ---\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let aggregatedText = \"\"; // To hold partial data\n\n    while (true) {\n      const {\n        value,\n        done\n      } = await reader.read();\n      if (done) break; // Stream finished\n\n      aggregatedText += decoder.decode(value, {\n        stream: true\n      });\n\n      // SSE (Server-Sent Events) format is data: { ... }\\n\\n\n      // We might get multiple chunks, so we split by newline\n      let jsonParts = aggregatedText.split('\\n');\n\n      // Keep the last part, it might be an incomplete chunk\n      aggregatedText = jsonParts.pop();\n      for (const part of jsonParts) {\n        if (part.startsWith('data: ')) {\n          try {\n            // Remove \"data: \" prefix and parse the JSON\n            const json = JSON.parse(part.substring(6));\n            // Extract the text chunk and send it back\n            const textChunk = json.candidates[0].content.parts[0].text;\n            onChunkCallback(textChunk); // Call the callback\n          } catch (e) {\n            console.error(\"Failed to parse stream chunk:\", e, part);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error(\"Gemini API call failed:\", error);\n    // Send a final error chunk to display\n    onChunkCallback(`\\n\\n--- Error connecting to Gemini API: ${error.message} ---`);\n  }\n};","map":{"version":3,"names":["sendMsgToAI","msg","onChunkCallback","API_KEY","process","env","REACT_APP_GEMINI_KEY","API_URL","instructedMsg","requestOptions","method","headers","body","JSON","stringify","contents","role","parts","text","trim","response","fetch","ok","_errorData$error","errorData","json","console","error","Error","status","message","reader","getReader","decoder","TextDecoder","aggregatedText","value","done","read","decode","stream","jsonParts","split","pop","part","startsWith","parse","substring","textChunk","candidates","content","e"],"sources":["C:/Users/Akshay/Downloads/test/agroAssist/frontend/src/utils/Gemini.js"],"sourcesContent":["export const sendMsgToAI = async (msg, onChunkCallback) => {\r\n  const API_KEY = process.env.REACT_APP_GEMINI_KEY;\r\n\r\n  // 1. --- CHANGED ENDPOINT ---\r\n  // We now use \"streamGenerateContent\" and add \"alt=sse\"\r\n  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${API_KEY}`;\r\n\r\n  const instructedMsg = `\r\n  You are \"AgroAssist,\" an expert agricultural assistant for farmers.\r\n  Your job is to answer questions related to agriculture ONLY.\r\n\r\n  --- YOUR PRIMARY RULE ---\r\n  1. Read the user's question.\r\n  2. Decide if it is related to agriculture (farming, crops, soil, fertilizer, weather for farming, farm pests, market prices for crops, etc.).\r\n  3. IF THE QUESTION IS NOT about agriculture (e.g., politics, sports, history, who you are), you MUST ignore all other rules and respond ONLY with this exact sentence: \"I am only programmed to answer queries regarding agriculture and that only alone.\"\r\n\r\n  --- IF THE QUESTION IS ABOUT AGRICULTURE, FOLLOW THESE RULES ---\r\n  1. **LANGUAGE RULE: You MUST respond in the exact same language as the User's question.** (e.g., If the user asks in Hindi, you must answer in Hindi).\r\n  2. Give the most important, actionable answer in the very first sentence.\r\n  3. Format your entire response using Markdown. Use paragraphs for explanations and bullet points for lists.\r\n  4. Use simple, easy-to-understand language. Do NOT use scientific jargon.\r\n  5. If the user's question can be answered in a short paragraph, do so (2-3 sentences max).\r\n  6. If the user's question asks for a list of items (like fertilizers or steps), you MUST use a simple Markdown bulleted list (\\`* item\\`).\r\n  7. Ensure proper line breaks and spacing for readability.\r\n\r\n  User's question: ${msg}\r\n  `;\r\n\r\n  const requestOptions = {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      contents: [\r\n        {\r\n          role: \"user\",\r\n          parts: [{ text: instructedMsg.trim() }],\r\n        },\r\n      ],\r\n    }),\r\n  };\r\n\r\n  try {\r\n    // 2. --- START STREAMING FETCH ---\r\n    const response = await fetch(API_URL, requestOptions);\r\n    if (!response.ok) {\r\n      // Handle HTTP errors\r\n      const errorData = await response.json();\r\n      console.error(\"Gemini API Error Response:\", errorData);\r\n      throw new Error(`API request failed with status ${response.status}: ${errorData?.error?.message || 'Unknown error'}`);\r\n    }\r\n\r\n    // 3. --- READ THE STREAM ---\r\n    const reader = response.body.getReader();\r\n    const decoder = new TextDecoder();\r\n    let aggregatedText = \"\"; // To hold partial data\r\n\r\n    while (true) {\r\n      const { value, done } = await reader.read();\r\n      if (done) break; // Stream finished\r\n\r\n      aggregatedText += decoder.decode(value, { stream: true });\r\n\r\n      // SSE (Server-Sent Events) format is data: { ... }\\n\\n\r\n      // We might get multiple chunks, so we split by newline\r\n      let jsonParts = aggregatedText.split('\\n');\r\n      \r\n      // Keep the last part, it might be an incomplete chunk\r\n      aggregatedText = jsonParts.pop(); \r\n\r\n      for (const part of jsonParts) {\r\n        if (part.startsWith('data: ')) {\r\n          try {\r\n            // Remove \"data: \" prefix and parse the JSON\r\n            const json = JSON.parse(part.substring(6));\r\n            // Extract the text chunk and send it back\r\n            const textChunk = json.candidates[0].content.parts[0].text;\r\n            onChunkCallback(textChunk); // Call the callback\r\n          } catch (e) {\r\n            console.error(\"Failed to parse stream chunk:\", e, part);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Gemini API call failed:\", error);\r\n    // Send a final error chunk to display\r\n    onChunkCallback(`\\n\\n--- Error connecting to Gemini API: ${error.message} ---`);\r\n  }\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}