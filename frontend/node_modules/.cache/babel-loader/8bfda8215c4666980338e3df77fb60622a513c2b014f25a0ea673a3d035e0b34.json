{"ast":null,"code":"export const sendMsgToAI = async (chatHistory, onChunkCallback) => {\n  const API_KEY = process.env.REACT_APP_GEMINI_KEY;\n\n  // 1. --- Re-enabled Streaming Endpoint ---\n  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${API_KEY}`;\n\n  // 2. --- STRICTER PROMPT ---\n  const systemPrompt = `\n  You are \"AgroAssist,\" an expert agricultural assistant for farmers.\n  Your job is to answer questions related to agriculture ONLY.\n\n  --- YOUR PRIMARY RULE ---\n  1. Read the user's question.\n  2. Decide if it is related to agriculture (farming, crops, soil, fertilizer, weather for farming, farm pests, market prices for crops, etc.).\n  3. IF THE QUESTION IS NOT about agriculture (e.g., politics, sports, history, who you are), you MUST ignore all other rules and respond ONLY with this exact sentence: \"I am only programmed to answer queries regarding agriculture and that only alone.\"\n\n  --- IF THE QUESTION IS ABOUT AGRICULTURE, FOLLOW THESE RULES ---\n  \n  1. **MOST IMPORTANT RULE: ASK FOR DETAILS FIRST.**\n     - If the user asks for a recommendation (like fertilizers, pesticides, or how to grow a crop), and you don't have details (like soil type, pH, location, season), your *entire response* MUST be a simple question asking for that missing information. \n     - **DO NOT** give a general answer and then ask a question. Your *only* response should be the question.\n     - Example: If the user asks \"How do I grow soybeans?\", you MUST respond with something like: \"To give you the best advice, could you please tell me your location, soil type, and the current season?\"\n  \n  2. **LANGUAGE RULE:** You MUST respond in the exact same language as the User's question.\n  3. **Format:** Format your entire response using Markdown. Use paragraphs for explanations and bullet points for lists.\n  4. **Simplicity:** Use simple, easy-to-understand language. Do NOT use scientific jargon.\n  5. **Brevity:** Keep answers to 2-3 sentences max, unless a list is required.\n  `;\n\n  // Convert your {isBot: bool, text: \"...\"} array to Gemini's format\n  const contents = chatHistory.map(msg => ({\n    role: msg.isBot ? \"model\" : \"user\",\n    parts: [{\n      text: msg.text\n    }]\n  }));\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      contents: contents,\n      // Send the full chat history\n      systemInstruction: {\n        // Send the rules separately\n        parts: [{\n          text: systemPrompt\n        }]\n      }\n    })\n  };\n  try {\n    // 3. --- START STREAMING FETCH ---\n    const response = await fetch(API_URL, requestOptions);\n    if (!response.ok) {\n      var _errorData$error;\n      const errorData = await response.json();\n      console.error(\"Gemini API Error Response:\", errorData);\n      throw new Error(`API request failed with status ${response.status}: ${(errorData === null || errorData === void 0 ? void 0 : (_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || 'Unknown error'}`);\n    }\n\n    // 4. --- READ THE STREAM ---\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let aggregatedText = \"\";\n    while (true) {\n      const {\n        value,\n        done\n      } = await reader.read();\n      if (done) break;\n      aggregatedText += decoder.decode(value, {\n        stream: true\n      });\n      let jsonParts = aggregatedText.split('\\n');\n      aggregatedText = jsonParts.pop();\n      for (const part of jsonParts) {\n        if (part.startsWith('data: ')) {\n          try {\n            const json = JSON.parse(part.substring(6));\n\n            // Check for valid text chunk\n            if (json.candidates && json.candidates[0].content.parts[0].text) {\n              const textChunk = json.candidates[0].content.parts[0].text;\n              onChunkCallback(textChunk); // Call the callback\n            }\n          } catch (e) {\n            // This can happen on the last chunk, it's often not a critical error\n            console.warn(\"Could not parse stream chunk:\", part);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error(\"Gemini API call failed:\", error);\n    onChunkCallback(`\\n\\n--- Error connecting to Gemini API: ${error.message} ---`);\n  }\n};","map":{"version":3,"names":["sendMsgToAI","chatHistory","onChunkCallback","API_KEY","process","env","REACT_APP_GEMINI_KEY","API_URL","systemPrompt","contents","map","msg","role","isBot","parts","text","requestOptions","method","headers","body","JSON","stringify","systemInstruction","response","fetch","ok","_errorData$error","errorData","json","console","error","Error","status","message","reader","getReader","decoder","TextDecoder","aggregatedText","value","done","read","decode","stream","jsonParts","split","pop","part","startsWith","parse","substring","candidates","content","textChunk","e","warn"],"sources":["C:/Users/Akshay/Downloads/test/agroAssist/frontend/src/utils/Gemini.js"],"sourcesContent":["export const sendMsgToAI = async (chatHistory, onChunkCallback) => {\r\n  const API_KEY = process.env.REACT_APP_GEMINI_KEY;\r\n\r\n  // 1. --- Re-enabled Streaming Endpoint ---\r\n  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${API_KEY}`;\r\n\r\n  // 2. --- STRICTER PROMPT ---\r\n  const systemPrompt = `\r\n  You are \"AgroAssist,\" an expert agricultural assistant for farmers.\r\n  Your job is to answer questions related to agriculture ONLY.\r\n\r\n  --- YOUR PRIMARY RULE ---\r\n  1. Read the user's question.\r\n  2. Decide if it is related to agriculture (farming, crops, soil, fertilizer, weather for farming, farm pests, market prices for crops, etc.).\r\n  3. IF THE QUESTION IS NOT about agriculture (e.g., politics, sports, history, who you are), you MUST ignore all other rules and respond ONLY with this exact sentence: \"I am only programmed to answer queries regarding agriculture and that only alone.\"\r\n\r\n  --- IF THE QUESTION IS ABOUT AGRICULTURE, FOLLOW THESE RULES ---\r\n  \r\n  1. **MOST IMPORTANT RULE: ASK FOR DETAILS FIRST.**\r\n     - If the user asks for a recommendation (like fertilizers, pesticides, or how to grow a crop), and you don't have details (like soil type, pH, location, season), your *entire response* MUST be a simple question asking for that missing information. \r\n     - **DO NOT** give a general answer and then ask a question. Your *only* response should be the question.\r\n     - Example: If the user asks \"How do I grow soybeans?\", you MUST respond with something like: \"To give you the best advice, could you please tell me your location, soil type, and the current season?\"\r\n  \r\n  2. **LANGUAGE RULE:** You MUST respond in the exact same language as the User's question.\r\n  3. **Format:** Format your entire response using Markdown. Use paragraphs for explanations and bullet points for lists.\r\n  4. **Simplicity:** Use simple, easy-to-understand language. Do NOT use scientific jargon.\r\n  5. **Brevity:** Keep answers to 2-3 sentences max, unless a list is required.\r\n  `;\r\n\r\n  // Convert your {isBot: bool, text: \"...\"} array to Gemini's format\r\n  const contents = chatHistory.map(msg => ({\r\n    role: msg.isBot ? \"model\" : \"user\",\r\n    parts: [{ text: msg.text }]\r\n  }));\r\n\r\n  const requestOptions = {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      contents: contents, // Send the full chat history\r\n      systemInstruction: { // Send the rules separately\r\n        parts: [{ text: systemPrompt }]\r\n      }\r\n    }),\r\n  };\r\n\r\n  try {\r\n    // 3. --- START STREAMING FETCH ---\r\n    const response = await fetch(API_URL, requestOptions);\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      console.error(\"Gemini API Error Response:\", errorData);\r\n      throw new Error(`API request failed with status ${response.status}: ${errorData?.error?.message || 'Unknown error'}`);\r\n    }\r\n\r\n    // 4. --- READ THE STREAM ---\r\n    const reader = response.body.getReader();\r\n    const decoder = new TextDecoder();\r\n    let aggregatedText = \"\"; \r\n\r\n    while (true) {\r\n      const { value, done } = await reader.read();\r\n      if (done) break; \r\n\r\n      aggregatedText += decoder.decode(value, { stream: true });\r\n      let jsonParts = aggregatedText.split('\\n');\r\n      aggregatedText = jsonParts.pop(); \r\n\r\n      for (const part of jsonParts) {\r\n        if (part.startsWith('data: ')) {\r\n          try {\r\n            const json = JSON.parse(part.substring(6));\r\n            \r\n            // Check for valid text chunk\r\n            if (json.candidates && json.candidates[0].content.parts[0].text) {\r\n              const textChunk = json.candidates[0].content.parts[0].text;\r\n              onChunkCallback(textChunk); // Call the callback\r\n            }\r\n          } catch (e) {\r\n            // This can happen on the last chunk, it's often not a critical error\r\n            console.warn(\"Could not parse stream chunk:\", part);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Gemini API call failed:\", error);\r\n    onChunkCallback(`\\n\\n--- Error connecting to Gemini API: ${error.message} ---`);\r\n  }\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}