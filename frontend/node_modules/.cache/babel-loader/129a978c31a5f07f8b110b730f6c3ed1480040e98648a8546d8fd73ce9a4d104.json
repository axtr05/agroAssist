{"ast":null,"code":"// src/utils/Gemini.js\n\n// Using the streaming version\nexport const sendMsgToAI = async (chatHistory, onChunkCallback) => {\n  const API_KEY = process.env.REACT_APP_GEMINI_KEY;\n  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${API_KEY}`;\n\n  // --- UPDATED PROMPT (Backticks Removed) ---\n  const systemPrompt = `\n  You are \"AgroAssist,\" an expert agricultural assistant for farmers, knowledgeable about common crops, seasons, and growing conditions, especially in India.\n  Your job is to answer questions related to agriculture ONLY.\n\n  --- YOUR PRIMARY RULE ---\n  1. Read the user's question.\n  2. Decide if it is related to agriculture.\n  3. IF NOT related to agriculture, respond ONLY with: \"I am only programmed to answer queries regarding agriculture and that only alone.\"\n\n  --- IF THE QUESTION IS ABOUT AGRICULTURE, FOLLOW THESE RULES ---\n\n  1. **CHECK FEASIBILITY FIRST (e.g., Seasonality):**\n     - Before giving advice or asking for details, use your agricultural knowledge to check if the user's request is feasible for the context (like growing a specific crop in a clearly wrong season).\n     - **If the request is clearly unsuitable** (e.g., \"I want to grow paddy/rice in winter\"), your **ENTIRE** response MUST politely correct them and state the correct season(s).\n     - **DO NOT** ask for location/soil details if the basic premise (like the season) is wrong for the requested crop.\n     - Example Correct Response (for \"grow paddy in winter\"): \"Paddy needs warm weather and plenty of water, so it cannot be grown in the winter season. The best time to plant paddy is during the Kharif season (monsoon, around June-July) or sometimes during the Rabi season (post-monsoon, around November) if irrigation is available.\"\n\n  2. **ASK FOR DETAILS IF NEEDED (and Feasible):**\n     - If the user's request *is* generally feasible (e.g., \"How to grow soybeans?\" without specifying winter), proceed to this step.\n     - If you lack necessary details (location, soil type/pH, season) to give a *specific* recommendation, your **ENTIRE** response MUST be **ONLY** the question(s) asking for that missing information.\n     - **DO NOT** add introductions, explanations, or any other text before or after the question.\n     - If asking multiple questions, use a concise numbered list.\n     - Example Correct Response (for \"How to grow soybeans?\"):\n       \"To give you the best advice, could you please tell me:\n       1. Your location?\n       2. Your soil type?\n       3. The current season?\"\n\n  3. **PROVIDE ANSWER (if Feasible and Details Sufficient):**\n     - If the request is feasible and you have enough details (or the question doesn't require specific details), proceed to answer according to the following rules.\n\n  4. **LANGUAGE RULE:** Respond in the exact same language as the User's question.\n  5. **Format:** Use Markdown (paragraphs, * for bullets, 1. for lists) unless asking questions per Rule 1 or 2.\n  6. **Simplicity:** Use simple language, no jargon.\n  7. **Brevity:** Keep answers brief (2-3 sentences or a short list) unless asking questions per Rule 1 or 2.\n  `;\n  // --- END OF PROMPT ---\n\n  // Convert chat history\n  const contents = chatHistory.map(msg => ({\n    role: msg.isBot ? \"model\" : \"user\",\n    parts: [{\n      text: msg.text\n    }]\n  }));\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      contents: contents,\n      systemInstruction: {\n        parts: [{\n          text: systemPrompt\n        }]\n      }\n    })\n  };\n  try {\n    // Streaming Fetch Logic\n    const response = await fetch(API_URL, requestOptions);\n    if (!response.ok) {\n      var _errorData$error;\n      const errorData = await response.json();\n      console.error(\"Gemini API Error Response:\", errorData);\n      throw new Error(`API request failed with status ${response.status}: ${(errorData === null || errorData === void 0 ? void 0 : (_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || 'Unknown error'}`);\n    }\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let aggregatedText = \"\";\n    while (true) {\n      const {\n        value,\n        done\n      } = await reader.read();\n      if (done) break;\n      aggregatedText += decoder.decode(value, {\n        stream: true\n      });\n      let jsonParts = aggregatedText.split('\\n');\n      aggregatedText = jsonParts.pop(); // Keep potentially incomplete last part\n\n      for (const part of jsonParts) {\n        if (part.startsWith('data: ')) {\n          try {\n            var _json$candidates, _json$candidates$, _json$candidates$$con, _json$candidates$$con2, _json$candidates$$con3, _json$candidates2, _json$candidates2$;\n            const json = JSON.parse(part.substring(6));\n            // Check structure before accessing text\n            if (json !== null && json !== void 0 && (_json$candidates = json.candidates) !== null && _json$candidates !== void 0 && (_json$candidates$ = _json$candidates[0]) !== null && _json$candidates$ !== void 0 && (_json$candidates$$con = _json$candidates$.content) !== null && _json$candidates$$con !== void 0 && (_json$candidates$$con2 = _json$candidates$$con.parts) !== null && _json$candidates$$con2 !== void 0 && (_json$candidates$$con3 = _json$candidates$$con2[0]) !== null && _json$candidates$$con3 !== void 0 && _json$candidates$$con3.text) {\n              const textChunk = json.candidates[0].content.parts[0].text;\n              onChunkCallback(textChunk); // Call the callback\n            } else if (json !== null && json !== void 0 && (_json$candidates2 = json.candidates) !== null && _json$candidates2 !== void 0 && (_json$candidates2$ = _json$candidates2[0]) !== null && _json$candidates2$ !== void 0 && _json$candidates2$.finishReason) {\n              // Handle potential end-of-stream signals if needed\n            }\n          } catch (e) {\n            console.warn(\"Could not parse stream chunk:\", part);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error(\"Gemini API call failed:\", error);\n    onChunkCallback(`\\n\\n--- Error connecting to Gemini API: ${error.message} ---`);\n  }\n};","map":{"version":3,"names":["sendMsgToAI","chatHistory","onChunkCallback","API_KEY","process","env","REACT_APP_GEMINI_KEY","API_URL","systemPrompt","contents","map","msg","role","isBot","parts","text","requestOptions","method","headers","body","JSON","stringify","systemInstruction","response","fetch","ok","_errorData$error","errorData","json","console","error","Error","status","message","reader","getReader","decoder","TextDecoder","aggregatedText","value","done","read","decode","stream","jsonParts","split","pop","part","startsWith","_json$candidates","_json$candidates$","_json$candidates$$con","_json$candidates$$con2","_json$candidates$$con3","_json$candidates2","_json$candidates2$","parse","substring","candidates","content","textChunk","finishReason","e","warn"],"sources":["C:/Users/Akshay/Downloads/test/agroAssist/frontend/src/utils/Gemini.js"],"sourcesContent":["// src/utils/Gemini.js\r\n\r\n// Using the streaming version\r\nexport const sendMsgToAI = async (chatHistory, onChunkCallback) => {\r\n  const API_KEY = process.env.REACT_APP_GEMINI_KEY;\r\n\r\n  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${API_KEY}`;\r\n\r\n  // --- UPDATED PROMPT (Backticks Removed) ---\r\n  const systemPrompt = `\r\n  You are \"AgroAssist,\" an expert agricultural assistant for farmers, knowledgeable about common crops, seasons, and growing conditions, especially in India.\r\n  Your job is to answer questions related to agriculture ONLY.\r\n\r\n  --- YOUR PRIMARY RULE ---\r\n  1. Read the user's question.\r\n  2. Decide if it is related to agriculture.\r\n  3. IF NOT related to agriculture, respond ONLY with: \"I am only programmed to answer queries regarding agriculture and that only alone.\"\r\n\r\n  --- IF THE QUESTION IS ABOUT AGRICULTURE, FOLLOW THESE RULES ---\r\n\r\n  1. **CHECK FEASIBILITY FIRST (e.g., Seasonality):**\r\n     - Before giving advice or asking for details, use your agricultural knowledge to check if the user's request is feasible for the context (like growing a specific crop in a clearly wrong season).\r\n     - **If the request is clearly unsuitable** (e.g., \"I want to grow paddy/rice in winter\"), your **ENTIRE** response MUST politely correct them and state the correct season(s).\r\n     - **DO NOT** ask for location/soil details if the basic premise (like the season) is wrong for the requested crop.\r\n     - Example Correct Response (for \"grow paddy in winter\"): \"Paddy needs warm weather and plenty of water, so it cannot be grown in the winter season. The best time to plant paddy is during the Kharif season (monsoon, around June-July) or sometimes during the Rabi season (post-monsoon, around November) if irrigation is available.\"\r\n\r\n  2. **ASK FOR DETAILS IF NEEDED (and Feasible):**\r\n     - If the user's request *is* generally feasible (e.g., \"How to grow soybeans?\" without specifying winter), proceed to this step.\r\n     - If you lack necessary details (location, soil type/pH, season) to give a *specific* recommendation, your **ENTIRE** response MUST be **ONLY** the question(s) asking for that missing information.\r\n     - **DO NOT** add introductions, explanations, or any other text before or after the question.\r\n     - If asking multiple questions, use a concise numbered list.\r\n     - Example Correct Response (for \"How to grow soybeans?\"):\r\n       \"To give you the best advice, could you please tell me:\r\n       1. Your location?\r\n       2. Your soil type?\r\n       3. The current season?\"\r\n\r\n  3. **PROVIDE ANSWER (if Feasible and Details Sufficient):**\r\n     - If the request is feasible and you have enough details (or the question doesn't require specific details), proceed to answer according to the following rules.\r\n\r\n  4. **LANGUAGE RULE:** Respond in the exact same language as the User's question.\r\n  5. **Format:** Use Markdown (paragraphs, * for bullets, 1. for lists) unless asking questions per Rule 1 or 2.\r\n  6. **Simplicity:** Use simple language, no jargon.\r\n  7. **Brevity:** Keep answers brief (2-3 sentences or a short list) unless asking questions per Rule 1 or 2.\r\n  `;\r\n  // --- END OF PROMPT ---\r\n\r\n  // Convert chat history\r\n  const contents = chatHistory.map(msg => ({\r\n    role: msg.isBot ? \"model\" : \"user\",\r\n    parts: [{ text: msg.text }]\r\n  }));\r\n\r\n  const requestOptions = {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      contents: contents,\r\n      systemInstruction: {\r\n        parts: [{ text: systemPrompt }]\r\n      }\r\n    }),\r\n  };\r\n\r\n  try {\r\n    // Streaming Fetch Logic\r\n    const response = await fetch(API_URL, requestOptions);\r\n    if (!response.ok) {\r\n      const errorData = await response.json();\r\n      console.error(\"Gemini API Error Response:\", errorData);\r\n      throw new Error(`API request failed with status ${response.status}: ${errorData?.error?.message || 'Unknown error'}`);\r\n    }\r\n\r\n    const reader = response.body.getReader();\r\n    const decoder = new TextDecoder();\r\n    let aggregatedText = \"\";\r\n\r\n    while (true) {\r\n      const { value, done } = await reader.read();\r\n      if (done) break;\r\n\r\n      aggregatedText += decoder.decode(value, { stream: true });\r\n      let jsonParts = aggregatedText.split('\\n');\r\n      aggregatedText = jsonParts.pop(); // Keep potentially incomplete last part\r\n\r\n      for (const part of jsonParts) {\r\n        if (part.startsWith('data: ')) {\r\n          try {\r\n            const json = JSON.parse(part.substring(6));\r\n            // Check structure before accessing text\r\n            if (json?.candidates?.[0]?.content?.parts?.[0]?.text) {\r\n              const textChunk = json.candidates[0].content.parts[0].text;\r\n              onChunkCallback(textChunk); // Call the callback\r\n            } else if (json?.candidates?.[0]?.finishReason) {\r\n              // Handle potential end-of-stream signals if needed\r\n            }\r\n          } catch (e) {\r\n             console.warn(\"Could not parse stream chunk:\", part);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Gemini API call failed:\", error);\r\n    onChunkCallback(`\\n\\n--- Error connecting to Gemini API: ${error.message} ---`);\r\n  }\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}