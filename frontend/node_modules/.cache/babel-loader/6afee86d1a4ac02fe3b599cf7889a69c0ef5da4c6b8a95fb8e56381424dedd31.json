{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Akshay\\\\Downloads\\\\test\\\\agroAssist\\\\frontend\\\\src\\\\utils\\\\Context.js\",\n  _s = $RefreshSig$();\n// src/utils/Context.js\n\nimport React, { createContext, useState, useRef, useEffect, useCallback } from \"react\";\nimport { sendMsgToAI } from \"./Gemini\"; // Ensure this is the streaming version\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ContextApp = /*#__PURE__*/createContext();\nfunction AppContext({\n  children\n}) {\n  _s();\n  const [showSlide, setShowSlide] = useState(false);\n  const [Mobile, setMobile] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [chatValue, setChatValue] = useState(\"\");\n  const [message, setMessage] = useState([]);\n  const msgEnd = useRef(null);\n  const [language, setLanguage] = useState('en-US');\n  useEffect(() => {\n    var _msgEnd$current;\n    // Scroll whenever messages change\n    (_msgEnd$current = msgEnd.current) === null || _msgEnd$current === void 0 ? void 0 : _msgEnd$current.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  }, [message]);\n\n  // --- SIMPLIFIED STREAMING handleSend ---\n  const handleSend = useCallback(async text => {\n    const promptText = text || chatValue;\n    if (promptText.trim() === \"\") return;\n    const userMessage = {\n      text: promptText,\n      isBot: false\n    };\n    const botMessagePlaceholder = {\n      text: \"\",\n      isBot: true\n    };\n\n    // Capture the history *before* adding the new messages\n    const historyForApi = [...message, userMessage];\n\n    // Update UI immediately with user message and empty bot message\n    setMessage(prev => [...prev, userMessage, botMessagePlaceholder]);\n    if (!text) {\n      setChatValue(\"\");\n    }\n    setLoading(true); // Indicate API call start\n\n    // Variable to accumulate chunks\n    let accumulatedResponse = \"\";\n    const onChunk = chunk => {\n      accumulatedResponse += chunk;\n      // Update the *last* message in the state with the accumulated text\n      setMessage(prevChunk => {\n        const updatedMessages = [...prevChunk];\n        // Ensure there's a last message to update\n        if (updatedMessages.length > 0) {\n          const lastMsgIndex = updatedMessages.length - 1;\n          // Only update if the last message is a bot message\n          if (updatedMessages[lastMsgIndex].isBot) {\n            updatedMessages[lastMsgIndex] = {\n              ...updatedMessages[lastMsgIndex],\n              text: accumulatedResponse\n            };\n          }\n        }\n        return updatedMessages;\n      });\n    };\n    try {\n      await sendMsgToAI(historyForApi, onChunk); // Call streaming function\n    } catch (error) {\n      console.error(\"Error sending message:\", error);\n      // Update last bot message with an error\n      setMessage(prevErr => {\n        const updatedMessages = [...prevErr];\n        if (updatedMessages.length > 0) {\n          const lastMsgIndex = updatedMessages.length - 1;\n          if (updatedMessages[lastMsgIndex].isBot) {\n            updatedMessages[lastMsgIndex] = {\n              ...updatedMessages[lastMsgIndex],\n              text: \"Sorry, an error occurred.\"\n            };\n          }\n        }\n        return updatedMessages;\n      });\n    } finally {\n      setLoading(false); // Indicate API call end\n    }\n  }, [chatValue, message]); // Include message in dependencies\n  // --- END SIMPLIFIED STREAMING handleSend ---\n\n  const handleKeyPress = useCallback(e => {\n    if (e.key === \"Enter\" && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  }, [handleSend]);\n\n  // handleQuery needs the same simplified logic\n  const handleQuery = useCallback(async e => {\n    const text = e.target.innerText;\n    if (!text) return;\n    const userMessage = {\n      text,\n      isBot: false\n    };\n    const botMessagePlaceholder = {\n      text: \"\",\n      isBot: true\n    };\n    const historyForApi = [...message, userMessage];\n    setMessage(prev => [...prev, userMessage, botMessagePlaceholder]);\n    setLoading(true);\n    let accumulatedResponse = \"\";\n    const onChunk = chunk => {\n      accumulatedResponse += chunk;\n      setMessage(prevChunk => {\n        const updatedMessages = [...prevChunk];\n        if (updatedMessages.length > 0) {\n          const lastMsgIndex = updatedMessages.length - 1;\n          if (updatedMessages[lastMsgIndex].isBot) {\n            updatedMessages[lastMsgIndex] = {\n              ...updatedMessages[lastMsgIndex],\n              text: accumulatedResponse\n            };\n          }\n        }\n        return updatedMessages;\n      });\n    };\n    try {\n      await sendMsgToAI(historyForApi, onChunk);\n    } catch (error) {\n      console.error(\"Error sending query:\", error);\n      setMessage(prevErr => {\n        const updatedMessages = [...prevErr];\n        if (updatedMessages.length > 0) {\n          const lastMsgIndex = updatedMessages.length - 1;\n          if (updatedMessages[lastMsgIndex].isBot) {\n            updatedMessages[lastMsgIndex] = {\n              ...updatedMessages[lastMsgIndex],\n              text: \"Sorry, an error occurred.\"\n            };\n          }\n        }\n        return updatedMessages;\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [message]); // Include message in dependencies\n\n  const contextValue = {\n    showSlide,\n    setShowSlide,\n    Mobile,\n    setMobile,\n    loading,\n    setLoading,\n    chatValue,\n    setChatValue,\n    message,\n    setMessage,\n    msgEnd,\n    handleSend,\n    handleKeyPress,\n    handleQuery,\n    language,\n    setLanguage\n  };\n  return /*#__PURE__*/_jsxDEV(ContextApp.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 169,\n    columnNumber: 5\n  }, this);\n}\n_s(AppContext, \"tEq6YPZ4Lky89GoRWo8HufcVcco=\");\n_c = AppContext;\nexport default AppContext;\nvar _c;\n$RefreshReg$(_c, \"AppContext\");","map":{"version":3,"names":["React","createContext","useState","useRef","useEffect","useCallback","sendMsgToAI","jsxDEV","_jsxDEV","ContextApp","AppContext","children","_s","showSlide","setShowSlide","Mobile","setMobile","loading","setLoading","chatValue","setChatValue","message","setMessage","msgEnd","language","setLanguage","_msgEnd$current","current","scrollIntoView","behavior","handleSend","text","promptText","trim","userMessage","isBot","botMessagePlaceholder","historyForApi","prev","accumulatedResponse","onChunk","chunk","prevChunk","updatedMessages","length","lastMsgIndex","error","console","prevErr","handleKeyPress","e","key","shiftKey","preventDefault","handleQuery","target","innerText","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Akshay/Downloads/test/agroAssist/frontend/src/utils/Context.js"],"sourcesContent":["// src/utils/Context.js\r\n\r\nimport React, { createContext, useState, useRef, useEffect, useCallback } from \"react\";\r\nimport { sendMsgToAI } from \"./Gemini\"; // Ensure this is the streaming version\r\n\r\nexport const ContextApp = createContext();\r\n\r\nfunction AppContext({ children }) {\r\n  const [showSlide, setShowSlide] = useState(false);\r\n  const [Mobile, setMobile] = useState(false);\r\n  const [loading, setLoading] = useState(false);\r\n  const [chatValue, setChatValue] = useState(\"\");\r\n  const [message, setMessage] = useState([]);\r\n  const msgEnd = useRef(null);\r\n  const [language, setLanguage] = useState('en-US');\r\n\r\n  useEffect(() => {\r\n    // Scroll whenever messages change\r\n    msgEnd.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  }, [message]);\r\n\r\n  // --- SIMPLIFIED STREAMING handleSend ---\r\n  const handleSend = useCallback(async (text) => {\r\n    const promptText = text || chatValue;\r\n    if (promptText.trim() === \"\") return;\r\n\r\n    const userMessage = { text: promptText, isBot: false };\r\n    const botMessagePlaceholder = { text: \"\", isBot: true };\r\n\r\n    // Capture the history *before* adding the new messages\r\n    const historyForApi = [...message, userMessage];\r\n\r\n    // Update UI immediately with user message and empty bot message\r\n    setMessage((prev) => [...prev, userMessage, botMessagePlaceholder]);\r\n\r\n    if (!text) {\r\n      setChatValue(\"\");\r\n    }\r\n\r\n    setLoading(true); // Indicate API call start\r\n\r\n    // Variable to accumulate chunks\r\n    let accumulatedResponse = \"\";\r\n\r\n    const onChunk = (chunk) => {\r\n      accumulatedResponse += chunk;\r\n      // Update the *last* message in the state with the accumulated text\r\n      setMessage((prevChunk) => {\r\n        const updatedMessages = [...prevChunk];\r\n        // Ensure there's a last message to update\r\n        if (updatedMessages.length > 0) {\r\n            const lastMsgIndex = updatedMessages.length - 1;\r\n            // Only update if the last message is a bot message\r\n            if (updatedMessages[lastMsgIndex].isBot) {\r\n                updatedMessages[lastMsgIndex] = {\r\n                    ...updatedMessages[lastMsgIndex],\r\n                    text: accumulatedResponse\r\n                };\r\n            }\r\n        }\r\n        return updatedMessages;\r\n      });\r\n    };\r\n\r\n    try {\r\n      await sendMsgToAI(historyForApi, onChunk); // Call streaming function\r\n    } catch (error) {\r\n      console.error(\"Error sending message:\", error);\r\n      // Update last bot message with an error\r\n      setMessage((prevErr) => {\r\n          const updatedMessages = [...prevErr];\r\n          if (updatedMessages.length > 0) {\r\n              const lastMsgIndex = updatedMessages.length - 1;\r\n              if (updatedMessages[lastMsgIndex].isBot) {\r\n                  updatedMessages[lastMsgIndex] = {\r\n                      ...updatedMessages[lastMsgIndex],\r\n                      text: \"Sorry, an error occurred.\"\r\n                  };\r\n              }\r\n          }\r\n          return updatedMessages;\r\n       });\r\n    } finally {\r\n      setLoading(false); // Indicate API call end\r\n    }\r\n\r\n  }, [chatValue, message]); // Include message in dependencies\r\n  // --- END SIMPLIFIED STREAMING handleSend ---\r\n\r\n  const handleKeyPress = useCallback((e) => {\r\n    if (e.key === \"Enter\" && !e.shiftKey) {\r\n      e.preventDefault();\r\n      handleSend();\r\n    }\r\n  }, [handleSend]);\r\n\r\n  // handleQuery needs the same simplified logic\r\n  const handleQuery = useCallback(async (e) => {\r\n    const text = e.target.innerText;\r\n    if (!text) return;\r\n\r\n    const userMessage = { text, isBot: false };\r\n    const botMessagePlaceholder = { text: \"\", isBot: true };\r\n    const historyForApi = [...message, userMessage];\r\n\r\n    setMessage((prev) => [...prev, userMessage, botMessagePlaceholder]);\r\n    setLoading(true);\r\n\r\n    let accumulatedResponse = \"\";\r\n    const onChunk = (chunk) => {\r\n      accumulatedResponse += chunk;\r\n      setMessage((prevChunk) => {\r\n        const updatedMessages = [...prevChunk];\r\n        if (updatedMessages.length > 0) {\r\n            const lastMsgIndex = updatedMessages.length - 1;\r\n             if (updatedMessages[lastMsgIndex].isBot) {\r\n                updatedMessages[lastMsgIndex] = {\r\n                    ...updatedMessages[lastMsgIndex],\r\n                    text: accumulatedResponse\r\n                };\r\n             }\r\n        }\r\n        return updatedMessages;\r\n      });\r\n    };\r\n\r\n    try {\r\n      await sendMsgToAI(historyForApi, onChunk);\r\n    } catch (error) {\r\n      console.error(\"Error sending query:\", error);\r\n      setMessage((prevErr) => {\r\n           const updatedMessages = [...prevErr];\r\n          if (updatedMessages.length > 0) {\r\n              const lastMsgIndex = updatedMessages.length - 1;\r\n              if (updatedMessages[lastMsgIndex].isBot) {\r\n                  updatedMessages[lastMsgIndex] = {\r\n                      ...updatedMessages[lastMsgIndex],\r\n                      text: \"Sorry, an error occurred.\"\r\n                  };\r\n              }\r\n          }\r\n          return updatedMessages;\r\n       });\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [message]); // Include message in dependencies\r\n\r\n  const contextValue = {\r\n    showSlide,\r\n    setShowSlide,\r\n    Mobile,\r\n    setMobile,\r\n    loading,\r\n    setLoading,\r\n    chatValue,\r\n    setChatValue,\r\n    message,\r\n    setMessage,\r\n    msgEnd,\r\n    handleSend,\r\n    handleKeyPress,\r\n    handleQuery,\r\n    language,\r\n    setLanguage,\r\n  };\r\n\r\n  return (\r\n    <ContextApp.Provider value={contextValue}>{children}</ContextApp.Provider>\r\n  );\r\n}\r\n\r\nexport default AppContext;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}